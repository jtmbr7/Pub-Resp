#include <iostream>
#include <vector>
#include <iomanip>
#include <fstream>

// I put all the contant variables up here, for example the numbers fo patterns, inputs, the width and hight of the images, the number of neurons and wieghts
const int n_patterns = 5, n_inputs = 3, width = 10, height = 16, n_neurons = width * height, n_weights = n_neurons * (n_neurons - 1) / 2;


// I also remade the input patterns to 1 dimentional arrays to simplify the indexing
int inputs[n_inputs][n_neurons] {
	{ 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, 1, 1, 1, 1, -1, -1, 1 , 1, -1, -1, -1, -1, -1, -1, -1, -1, 1 , 1, -1, -1, -1, -1, -1, -1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 , 1, 1, 1, 1, 1, 1, 1, -1, -1, 1 },
	{ -1, -1, -1, -1, -1, -1, -1, -1, 1, 1 , -1, -1, -1, -1, -1, -1, -1, -1, 1, 1 , -1, -1, -1, -1, -1, 1, 1, 1, -1, -1 , -1, -1, -1, -1, -1, 1, 1, 1, -1, -1 , -1, -1, -1, -1, -1, 1, 1, 1, -1, -1 , -1, -1, -1, -1, -1, 1, 1, 1, -1, -1 , -1, -1, -1, -1, -1, 1, 1, 1, -1, -1 , 1, 1, 1, 1, 1, 1, 1, 1, -1, -1 , 1, 1, 1, 1, 1, 1, 1, 1, -1, -1 , 1, 1, 1, -1, -1, -1, -1, -1, -1, -1 , 1, 1, 1, -1, -1, -1, -1, -1, -1, -1 , 1, 1, 1, -1, -1, -1, -1, -1, -1, -1 , 1, 1, 1, -1, -1, -1, -1, -1, -1, -1 , 1, 1, 1, -1, -1, -1, -1, -1, -1, -1 , 1, 1, 1, 1, 1, 1, 1, 1, -1, -1 , 1, 1, 1, 1, 1, 1, 1, 1, -1, -1 },
	{ 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, -1, 1, -1, 1, 1, -1, -1 , 1, 1, -1, 1, -1, 1, -1, 1, -1, -1 , 1, 1, -1, 1, -1, 1, -1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 , 1, -1, 1, -1, 1, -1, 1, 1, -1, -1 }
};

int patterns[n_patterns][n_neurons] {
	{ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
	{ -1, -1, -1, 1, 1, 1, 1, -1, -1, -1 , -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1},
	{ 1, 1, 1, 1, 1, 1, 1, 1, -1, -1 , 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1},
	{ -1, -1, 1, 1, 1, 1, 1, 1, -1, -1 , -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1},
	{ -1, 1, 1, -1, -1, -1, -1, 1, 1, -1 ,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, -1, -1, -1, -1, 1, 1, -1,-1, 1, 1, 1, 1, 1, 1, 1, 1, -1,-1, 1, 1, 1, 1, 1, 1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1,-1, -1, -1, -1, -1, -1, -1, 1, 1, -1}
};

class HopfieldNetwork {
public:
	HopfieldNetwork() {

		for (int i = 0; i < n_neurons - 1; ++i)
			for (int j = i + 1; j < n_neurons; ++j)
				getWeight(i, j) = calculateWeight(i, j);
		
	}

	double& getWeight(double i, double j) {

		if (i > j)
			std::swap(i, j);

		return weights[(int)(j - 1 + i * (n_neurons - 1 - (i + 1) / 2))];
	}

	double calculateWeight(int i, int j) {
		double w = 0;
		for (int p = 0; p < n_patterns; ++p)
			w += patterns[p][i] * patterns[p][j];

		return w / n_neurons;
	}

	void loadInput(int p) {
		for (int i = 0; i < n_neurons; ++i)
			pattern[i] = inputs[p][i];
	}

	bool asynchronouslyUpdate() {

		bool steadyState = true; // Keeps track of steadyStates, becomes false if any neurons are updated.

		for(int i = 0; i < n_neurons; ++i) {

			double s = 0; // New state to be calculated
			for (int j = 0; j < n_neurons; ++j) {

				if (i == j) // Do not let neuron affect iself
					continue;

				s += pattern[j] * getWeight(i, j); // Sum all s_j * w_ij
			}

			if (s == 0)
				s = 1;
			else s /= std::abs(s); // "Sign" the new state, making sure it is either 1 or -1

			if (pattern[i] != s)
				steadyState = false;
			pattern[i] = s;
		}

		return steadyState;
	}

	void print() const {
		for (int i = 0; i < n_neurons; ++i) {
			std::cout << (pattern[i] == 1 ? "x" : " ");
			if ((i + 1) % width == 0)
				std::cout << "\n";
		}

		std::cout << "\n";
	}

	void writeToFile(std::ofstream& os) {

		os << "[[";
		for (int i = 0; i < n_neurons; ++i) {
			os << pattern[i];
			if (i == n_neurons - 1)
				os << "]]";
			else if ((i + 1) % width == 0)
				os << "],[";
			else os << ",";
		}

		os << "\n";
	}

	double weights[n_weights];
	int pattern[n_neurons];
};

int main()
{
	std::ofstream outputFile("output.txt");
	HopfieldNetwork hn{};

	for(int i = 0; i < n_inputs; ++i) {
		hn.loadInput(i);
		hn.print();

		while (!hn.asynchronouslyUpdate()) {}
		hn.print();
		hn.writeToFile(outputFile);
	}

	outputFile.close();
}